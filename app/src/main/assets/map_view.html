<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- CSS and JS will be injected here by Android -->
    <link rel="stylesheet" href="file:///android_asset/ol.css" />
    <script src="file:///android_asset/ol.js"></script>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
      }

      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <script>
      let map;
      let vectorSources = [];
      let lastZoomLevel = null;

      function reloadLayer(index) {
        const layer = map.getLayers().item(index);
        const source = layer.getSource();
        source.refresh();
      }

      function setLayers(layers) {
        map.getLayers().clear();
        vectorSources = [];
        layers.forEach((layer) => {
          if (layer.type === "tile") {
            addTileLayer(layer.url, layer.opacity);
          } else if (layer.type === "geojson") {
            addGeoJsonLayer(layer.url, layer.refreshOnZoom, layer.opacity);
          }
        });
      }

      function setCenter(lat, lon, zoom) {
        const view = map.getView();
        const center = ol.proj.fromLonLat([lon, lat]);
        view.setCenter(center);
        if (zoom !== undefined) {
          view.setZoom(zoom);
        }
      }

      function getColorString(color) {
        if (typeof color === "string") {
          return color;
        }
        const a = (color >>> 24) & 0xff;
        const r = (color >> 16) & 0xff;
        const g = (color >> 8) & 0xff;
        const b = color & 0xff;
        return `rgba(${r}, ${g}, ${b}, ${a / 255})`;
      }

      function dpToPixels(dp) {
        return dp * (window.devicePixelRatio || 1);
      }

      function setZoom(zoom) {
        const view = map.getView();
        view.setZoom(zoom);
      }

      function colorWithOpacity(colorString, opacity) {
        if (colorString.startsWith("rgba")) {
          return colorString.replace(
            /rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/,
            function (match, r, g, b, a) {
              return `rgba(${r}, ${g}, ${b}, ${opacity})`;
            },
          );
        } else if (colorString.startsWith("rgb")) {
          return colorString.replace(
            /rgb\((\d+),\s*(\d+),\s*(\d+)\)/,
            function (match, r, g, b) {
              return `rgba(${r}, ${g}, ${b}, ${opacity})`;
            },
          );
        }
        return colorString;
      }

      function addGeoJsonLayer(url, refreshOnZoom, opacity) {
        const vectorSource = new ol.source.Vector({
          format: new ol.format.GeoJSON(),
          url: function (extent) {
            const extent4326 = ol.proj.transformExtent(
              extent,
              map.getView().getProjection(),
              "EPSG:4326",
            );
            return url.replace("{bbox}", extent4326.join(","));
          },
          strategy: ol.loadingstrategy.bbox,
        });

        vectorSources.push({
          source: vectorSource,
          refreshOnZoom: refreshOnZoom,
        });

        const vectorLayer = new ol.layer.Vector({
          source: vectorSource,
          opacity: opacity || 1.0,
          style: function (feature, resolution) {
            const geometryType = feature.getGeometry().getType();
            let strokeColor = getColorString(
              feature.getProperties()["strokeColor"] || "transparent",
            );
            let fillColor = getColorString(
              feature.getProperties()["color"] || "transparent",
            );
            const featureOpacity = feature.getProperties()["opacity"];
            if (featureOpacity !== undefined) {
              strokeColor = colorWithOpacity(strokeColor, featureOpacity / 255);
              fillColor = colorWithOpacity(fillColor, featureOpacity / 255);
            }
            const strokeWeight = feature.getProperties()["strokeWeight"] || 1;
            // TODO: This should be converted from DP to pixels
            const strokeWidth = strokeWeight;

            const style = {
              stroke: new ol.style.Stroke({
                color: strokeColor,
                width: strokeWidth
              }),
            };

            if (geometryType.includes("Polygon")) {
              style.fill = new ol.style.Fill({
                color: fillColor
              });
            } else if (geometryType.includes("Point")) {
              let size = feature.getProperties()["size"] || 5;
              const sizeUnit = feature.getProperties()["sizeUnit"] || "px";
              if (sizeUnit === "dp") {
                size = dpToPixels(size);
              } else if (sizeUnit === "m") {
                size = size / resolution;
              }
              style.image = new ol.style.Circle({
                radius: size,
                fill: new ol.style.Fill({
                  color: fillColor
                }),
                stroke: new ol.style.Stroke({
                  color: strokeColor,
                  width: 2
                }),
              });
            }

            return new ol.style.Style(style);
          },
        });

        map.addLayer(vectorLayer);
      }

      function addTileLayer(url, opacity) {
        const tileLayer = new ol.layer.Tile({
          source: new ol.source.XYZ({
            url: url,
          }),
          opacity: opacity || 1.0,
        });
        map.addLayer(tileLayer);
      }

      function getFeatures(x, y) {
        const features = [];
        map.forEachFeatureAtPixel([x, y], function (feature, layer) {
          features.push(feature);
        });
        return features;
      }

      function getZoom() {
        return map.getView().getZoom();
      }

      function getCenter() {
        const center = ol.proj.toLonLat(map.getView().getCenter());
        return { latitude: center[1], longitude: center[0] };
      }

      function onBoundsChanged() {
        if (window.AndroidMap && window.AndroidMap.onBoundsChanged) {
          const bounds = getBounds();
          window.AndroidMap.onBoundsChanged(
            bounds.south,
            bounds.west,
            bounds.north,
            bounds.east,
          );
        }
      }

      function setupClickListeners() {
        let longClickTimer;
        let startX, startY;
        const longClickThreshold = 500; // ms
        const moveThreshold = 10; // pixels

        map.on("pointerdown", function (event) {
          startX = event.pixel[0];
          startY = event.pixel[1];
          longClickTimer = setTimeout(() => {
            const coord = ol.proj.toLonLat(event.coordinate);
            if (window.AndroidMap) {
              window.AndroidMap.onLongClick(coord[1], coord[0]);
            }
            longClickTimer = null;
          }, longClickThreshold);
        });

        map.on("pointerup", function () {
          if (longClickTimer) {
            clearTimeout(longClickTimer);
            longClickTimer = null;
          }
        });

        map.on("pointermove", function (event) {
          if (longClickTimer) {
            const dx = event.pixel[0] - startX;
            const dy = event.pixel[1] - startY;
            if (Math.abs(dx) > moveThreshold || Math.abs(dy) > moveThreshold) {
              clearTimeout(longClickTimer);
              longClickTimer = null;
            }
          }
        });

        map.on("singleclick", function (event) {
          const coord = ol.proj.toLonLat(event.coordinate);
          if (window.AndroidMap) {
            window.AndroidMap.onSingleClick(coord[1], coord[0]);
          }
        });
      }

      function getBounds() {
        const extent = ol.proj.transformExtent(
          map.getView().calculateExtent(map.getSize()),
          map.getView().getProjection(),
          "EPSG:4326",
        );
        return {
          south: extent[1],
          west: extent[0],
          north: extent[3],
          east: extent[2],
        };
      }

      function setRotation(rotation) {
        map.getView().setRotation(rotation);
      }

      function initializeMap() {
        map = new ol.Map({
          controls: [],
          target: "map",
          layers: [],
          view: new ol.View({
            center: ol.proj.fromLonLat([0, 0]),
            zoom: 2,
          }),
        });

        // Disable rotation interaction by default
        map.getInteractions().forEach(function (interaction) {
          if (
            interaction instanceof ol.interaction.DragRotate ||
            interaction instanceof ol.interaction.PinchRotate
          ) {
            map.removeInteraction(interaction);
          }
        });

        map.on("click", function (evt) {
          const coordinate = ol.proj.toLonLat(evt.coordinate);
          const lon = coordinate[0];
          const lat = coordinate[1];
          const features = getFeatures(evt.pixel[0], evt.pixel[1]);
          console.log("Map clicked at:", lon, lat);
          console.log("Features at clicked location:", features);
        });

        map.getView().on("change:resolution", function () {
          if (window.AndroidMap && window.AndroidMap.onZoomChanged) {
            const zoom = getZoom();
            window.AndroidMap.onZoomChanged(zoom);
          }
          onBoundsChanged();
          const currentZoomLevel = Math.floor(getZoom());
          if (lastZoomLevel !== currentZoomLevel) {
            vectorSources.forEach((item) => {
              if (item.refreshOnZoom) {
                item.source.refresh();
              }
            });
            lastZoomLevel = currentZoomLevel;
          }
        });

        map.getView().on("change:center", function () {
          if (window.AndroidMap && window.AndroidMap.onCenterChanged) {
            const center = getCenter();
            window.AndroidMap.onCenterChanged(
              center.latitude,
              center.longitude,
            );
          }
          onBoundsChanged();
        });

        setupClickListeners();
      }

      function setup() {
        initializeMap();

        if (window.onMapReady) {
          window.onMapReady();
        }
      }

      window.MapInterface = {
        setLayers: setLayers,
        setCenter: setCenter,
        setZoom: setZoom,
        reloadLayer: reloadLayer,
        getZoom: getZoom,
        getCenter: getCenter,
        getBounds: getBounds,
        setRotation: setRotation,
      };

      window.addEventListener("load", setup);
    </script>
  </body>
</html>
