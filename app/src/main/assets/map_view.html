<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- CSS and JS will be injected here by Android -->
    <link rel="stylesheet" href="file:///android_asset/ol.css" />
    <script src="file:///android_asset/ol.js"></script>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
      }

      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <script>
      let map;

      function reloadLayer(index) {
        const layer = map.getLayers().item(index);
        const source = layer.getSource();
        source.refresh();
      }

      function setLayers(layers) {
        map.getLayers().clear();
        layers.forEach((layer) => {
          if (layer.type === "tile") {
            addTileLayer(layer.url, layer.opacity);
          } else if (layer.type === "geojson") {
            addGeoJsonLayer(layer.url);
          }
        });
      }

      function setCenter(lat, lon, zoom) {
        const view = map.getView();
        const center = ol.proj.fromLonLat([lon, lat]);
        view.setCenter(center);
        if (zoom !== undefined) {
          view.setZoom(zoom);
        }
      }

      function setZoom(zoom) {
        const view = map.getView();
        view.setZoom(zoom);
      }

      function addGeoJsonLayer(url) {
        const vectorSource = new ol.source.Vector({
          format: new ol.format.GeoJSON(),
          url: function (extent) {
            const extent4326 = ol.proj.transformExtent(
              extent,
              map.getView().getProjection(),
              "EPSG:4326",
            );
            return url.replace("{bbox}", extent4326.join(","));
          },
          strategy: ol.loadingstrategy.bbox,
        });

        const vectorLayer = new ol.layer.Vector({
          source: vectorSource,
          style: function (feature, resolution) {
            return new ol.style.Style({
              fill: new ol.style.Fill({
                color: "rgba(0, 123, 255, 0.5)",
              }),
              stroke: new ol.style.Stroke({
                color: "#007bff",
                width: 1,
              }),
            });
          },
        });

        map.addLayer(vectorLayer);
      }

      function addTileLayer(url, opacity) {
        const tileLayer = new ol.layer.Tile({
          source: new ol.source.XYZ({
            url: url,
          }),
          opacity: opacity || 1.0,
        });
        map.addLayer(tileLayer);
      }

      function getFeatures(x, y) {
        const features = [];
        map.forEachFeatureAtPixel([x, y], function (feature, layer) {
          features.push(feature);
        });
        return features;
      }

      function getZoom() {
        return map.getView().getZoom();
      }

      function getCenter() {
        const center = ol.proj.toLonLat(map.getView().getCenter());
        return { latitude: center[1], longitude: center[0] };
      }

      function onBoundsChanged() {
        if (window.AndroidMap && window.AndroidMap.onBoundsChanged) {
          const bounds = getBounds();
          window.AndroidMap.onBoundsChanged(
            bounds.south,
            bounds.west,
            bounds.north,
            bounds.east,
          );
        }
      }

      function setupClickListeners() {
        let longClickTimer;
        let startX, startY;
        const longClickThreshold = 500; // ms
        const moveThreshold = 10; // pixels

        map.on("pointerdown", function (event) {
          startX = event.pixel[0];
          startY = event.pixel[1];
          longClickTimer = setTimeout(() => {
            const coord = ol.proj.toLonLat(event.coordinate);
            if (window.AndroidMap) {
              window.AndroidMap.onLongClick(coord[1], coord[0]);
            }
            longClickTimer = null;
          }, longClickThreshold);
        });

        map.on("pointerup", function () {
          if (longClickTimer) {
            clearTimeout(longClickTimer);
            longClickTimer = null;
          }
        });

        map.on("pointermove", function (event) {
          if (longClickTimer) {
            const dx = event.pixel[0] - startX;
            const dy = event.pixel[1] - startY;
            if (Math.abs(dx) > moveThreshold || Math.abs(dy) > moveThreshold) {
              clearTimeout(longClickTimer);
              longClickTimer = null;
            }
          }
        });

        map.on("singleclick", function (event) {
          const coord = ol.proj.toLonLat(event.coordinate);
          if (window.AndroidMap) {
            window.AndroidMap.onSingleClick(coord[1], coord[0]);
          }
        });
      }

      function getBounds() {
        const extent = ol.proj.transformExtent(
          map.getView().calculateExtent(map.getSize()),
          map.getView().getProjection(),
          "EPSG:4326",
        );
        return {
          south: extent[1],
          west: extent[0],
          north: extent[3],
          east: extent[2],
        };
      }

      function setRotation(rotation) {
        map.getView().setRotation(rotation);
      }

      function initializeMap() {
        map = new ol.Map({
          controls: [],
          target: "map",
          layers: [],
          view: new ol.View({
            center: ol.proj.fromLonLat([0, 0]),
            zoom: 2
          }),
        });
        
        // Disable rotation interaction by default
        map.getInteractions().forEach(function (interaction) {
          if (interaction instanceof ol.interaction.DragRotate ||
              interaction instanceof ol.interaction.PinchRotate) {
            map.removeInteraction(interaction);
          }
        });

        map.on("click", function (evt) {
          const coordinate = ol.proj.toLonLat(evt.coordinate);
          const lon = coordinate[0];
          const lat = coordinate[1];
          const features = getFeatures(evt.pixel[0], evt.pixel[1]);
          console.log("Map clicked at:", lon, lat);
          console.log("Features at clicked location:", features);
        });

        map.getView().on("change:resolution", function () {
          if (window.AndroidMap && window.AndroidMap.onZoomChanged) {
            const zoom = getZoom();
            window.AndroidMap.onZoomChanged(zoom);
          }
          onBoundsChanged();
        });

        map.getView().on("change:center", function () {
          if (window.AndroidMap && window.AndroidMap.onCenterChanged) {
            const center = getCenter();
            window.AndroidMap.onCenterChanged(
              center.latitude,
              center.longitude,
            );
          }
          onBoundsChanged();
        });

        setupClickListeners();
      }

      function setup() {
        initializeMap();

        if (window.onMapReady) {
          window.onMapReady();
        }
      }

      window.MapInterface = {
        setLayers: setLayers,
        setCenter: setCenter,
        setZoom: setZoom,
        reloadLayer: reloadLayer,
        getZoom: getZoom,
        getCenter: getCenter,
        getBounds: getBounds,
        setRotation: setRotation,
      };

      window.addEventListener("load", setup);
    </script>
  </body>
</html>
